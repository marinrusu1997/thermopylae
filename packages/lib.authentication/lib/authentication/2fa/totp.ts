import type { AuthenticatorOptions } from '@otplib/core';
import { Authenticator } from '@otplib/core';
import { createDigest, createRandomBytes } from '@otplib/plugin-crypto';
import { keyDecoder, keyEncoder } from '@otplib/plugin-thirty-two';
import type { RequireSome } from '@thermopylae/core.declarations';
import qrcode from 'qrcode';
import { ErrorCodes, createException } from '../../error.js';
import type { AuthenticationSessionRepositoryHolder } from '../../helpers/authentication-session-repository-holder.js';
import { SecretEncryptor } from '../../helpers/secret-encryptor.js';
import type { SecretEncryptionOptions } from '../../helpers/secret-encryptor.js';
import type { AuthenticationContext } from '../../types/contexts.js';
import type { AccountModel } from '../../types/models.js';
import type { TwoFactorAuthStrategy } from './interface.js';

/** Result returned by {@link TotpTwoFactorAuthStrategy.onTwoFactorAuthEnabled} hook. */
interface OnTwoFactorEnabledHookResult {
	/**
	 * URL of the QR Image containing totp secret. <br/> Image needs to be displayed to client, so
	 * that he can scan it with the Authenticator app.
	 */
	totpSecretQRImageUrl: string;
}

/** User account which contains TOTP secret. */
interface AccountWithTotpSecret extends AccountModel {
	/** Totp secret used at totp generation. */
	totpSecret: string;
}

interface TotpTwoFactorAuthStrategyOptions {
	/** TOTP related options. */
	readonly totp: {
		/** TOTP secret length. */
		secretLength: number;
		/**
		 * This option dictates how totp secret will be stored by
		 * {@link AccountWithTotpSecret.totpSecret} property (i.e. how it will be stored in data
		 * storage). <br/> Depending on the value, the following behaviour will be employed:
		 *
		 * - _false_ - totp secret will be stored in plaintext (unsecure, but faster)
		 * - _{@link SecretEncryptionOptions}_ - totp secret will be encrypted before being stored
		 *   (secure, but a bit slower as crypto is implied)
		 */
		encryption: SecretEncryptionOptions | false;
		/** TOTP authenticator [options](https://www.npmjs.com/package/otplib#available-options). */
		authenticator: Readonly<
			Omit<
				RequireSome<AuthenticatorOptions, 'algorithm' | 'digits' | 'encoding' | 'step' | 'window'>,
				'createDigest' | 'createHmacKey' | 'digest' | 'epoch' | 'createRandomBytes' | 'keyEncoder' | 'keyDecoder'
			>
		>;
	};
	/**
	 * Service name used for QR code containing totp secret. More details can be found
	 * [here](https://www.npmjs.com/package/otplib#displaying-a-qr-code).
	 */
	readonly serviceName: string;
}

/**
 * Two factor authentication strategy which uses
 * [TOTP](https://en.wikipedia.org/wiki/Time-based_One-Time_Password) mechanism. <br/> When 2fa is
 * enabled, the strategy will generate a secret, which will be sent to client as QR Image Code (see
 * {@link OnTwoFactorEnabledHookResult.totpSecretQRImageUrl}). Client has to scan this image with his
 * Authenticator App. <br/> During authentication process, when client will receive
 * {@link AuthenticationStepName.TWO_FACTOR_AUTH_CHECK} as {@link AuthenticationStatus.nextStep}, he
 * needs to send back 2fa token generated by his app to complete authentication.
 */
class TotpTwoFactorAuthStrategy<Account extends AccountWithTotpSecret> implements TwoFactorAuthStrategy<Account> {
	private readonly authenticator: Authenticator;

	private readonly totpEncryptor: SecretEncryptor;

	private readonly totpSecretLength: number;

	private readonly serviceName: string;

	public constructor(options: TotpTwoFactorAuthStrategyOptions) {
		this.authenticator = new Authenticator({
			...options.totp.authenticator,
			createDigest,
			createRandomBytes,
			keyDecoder,
			keyEncoder
		});
		this.totpEncryptor = new SecretEncryptor(options.totp.encryption);
		this.totpSecretLength = options.totp.secretLength;
		this.serviceName = options.serviceName;
	}

	/**
	 * Generates totp secret and stores it into account. After that method will generate a QR Image
	 * containing secret and return it's URL to client.
	 */
	public async onTwoFactorAuthEnabled(account: Readonly<Account>, update: Partial<Account>): Promise<OnTwoFactorEnabledHookResult> {
		const totpSecret = this.authenticator.generateSecret(this.totpSecretLength);
		update.totpSecret = this.totpEncryptor.encrypt(totpSecret);

		const otpAuth = this.authenticator.keyuri(account.username, this.serviceName, totpSecret);
		return {
			totpSecretQRImageUrl: await qrcode.toDataURL(otpAuth)
		};
	}

	/**
	 * Marks in the {@link AuthenticationSession} that
	 * {@link AuthenticationStepName.GENERATE_2FA_TOKEN} has been passed, and the next step is to
	 * validate token from the Authenticator App sent by client. <br/> An attempt to come back to
	 * {@link AuthenticationStepName.GENERATE_2FA_TOKEN} step until previous token validation will
	 * result into an error.
	 */
	public async sendAuthenticationToken(
		account: AccountModel,
		_authenticationContext: AuthenticationContext,
		authenticationSessionRepositoryHolder: AuthenticationSessionRepositoryHolder
	): Promise<void> {
		const authenticationSession = await authenticationSessionRepositoryHolder.get();
		if (authenticationSession.twoFactorAuthenticationToken != null) {
			throw createException(
				ErrorCodes.TWO_FACTOR_AUTH_TOKEN_ISSUED_ALREADY,
				`Two factor authentication token was issued already for authentication session with id '${authenticationSessionRepositoryHolder.sessionId}' belonging to account with id '${account.id}'.`
			);
		}

		authenticationSession.twoFactorAuthenticationToken = 'totp-2fa-marker'; // just to enforce totp as second factor, and not to allow password bypass

		// we do not send any code, because it will be generated by user and sent to us
	}

	/**
	 * Marks in the {@link AuthenticationSession} that
	 * {@link AuthenticationStepName.TWO_FACTOR_AUTH_CHECK} step has been passed (in case valid token
	 * is sent by client), and authentication can be finished.
	 */
	public async isAuthenticationTokenValid(
		account: Account,
		authenticationContext: AuthenticationContext,
		authenticationSessionRepositoryHolder: AuthenticationSessionRepositoryHolder
	): Promise<boolean> {
		const authenticationSession = await authenticationSessionRepositoryHolder.get();

		if (authenticationSession.twoFactorAuthenticationToken !== 'totp-2fa-marker') {
			return false;
		}

		if (this.authenticator.check(authenticationContext.twoFactorAuthenticationToken!, this.totpEncryptor.decrypt(account.totpSecret))) {
			delete authenticationSession.twoFactorAuthenticationToken; // prevent replay attacks
			return true;
		}

		return false;
	}
}

export { TotpTwoFactorAuthStrategy };
export type { TotpTwoFactorAuthStrategyOptions, AccountWithTotpSecret, OnTwoFactorEnabledHookResult };
