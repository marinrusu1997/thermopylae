import qrcode from 'qrcode';
import type { RequireSome } from '@thermopylae/core.declarations/lib';
import type { AuthenticatorOptions } from '@otplib/core';
import { Authenticator } from '@otplib/core';
import { createDigest, createRandomBytes } from '@otplib/plugin-crypto';
import { keyDecoder, keyEncoder } from '@otplib/plugin-thirty-two';
import { createException, ErrorCodes } from '../../error';
import { SecretEncryptor } from '../../helpers/secret-encryptor';
import type { AuthenticationContext } from '../../types/contexts';
import type { AccountModel } from '../../types/models';
import type { SecretEncryptionOptions } from '../../helpers/secret-encryptor';
import type { TwoFactorAuthStrategy } from './interface';
import type { AuthenticationSessionRepositoryHolder } from '../../helpers/authentication-session-repository-holder';

/**
 * Result returned by {@link TotpTwoFactorAuthStrategy.onTwoFactorAuthEnabled} hook.
 */
interface OnTwoFactorEnabledHookResult {
	/**
	 * URL of the QR Image containing totp secret. <br/>
	 * Image needs to be displayed to client, so that he can scan it with the Authenticator app.
	 */
	totpSecretQRImageUrl: string;
}

/**
 * User account which contains TOTP secret.
 */
interface AccountWithTotpSecret extends AccountModel {
	/**
	 * Totp secret used at totp generation.
	 */
	totpSecret: string;
}

interface TotpTwoFactorAuthStrategyOptions {
	/**
	 * TOTP related options.
	 */
	readonly totp: {
		/**
		 * TOTP secret length.
		 */
		secretLength: number;
		/**
		 * This option dictates how totp secret will be stored by {@link AccountWithTotpSecret.totpSecret} property (i.e. how it will be stored in data storage). <br/>
		 * Depending on the value, the following behaviour will be employed:
		 * - *false* - totp secret will be stored in plaintext (unsecure, but faster)
		 * - *{@link SecretEncryptionOptions}* - totp secret will be encrypted before being stored (secure, but a bit slower as crypto is implied)
		 */
		encryption: SecretEncryptionOptions | false;
		/**
		 * TOTP authenticator [options](https://www.npmjs.com/package/otplib#available-options).
		 */
		authenticator: Readonly<
			Omit<
				RequireSome<AuthenticatorOptions, 'algorithm' | 'digits' | 'encoding' | 'step' | 'window'>,
				'createDigest' | 'createHmacKey' | 'digest' | 'epoch' | 'createRandomBytes' | 'keyEncoder' | 'keyDecoder'
			>
		>;
	};
	/**
	 * Service name used for QR code containing totp secret. More details can be found [here](https://www.npmjs.com/package/otplib#displaying-a-qr-code).
	 */
	readonly serviceName: string;
}

/**
 * Two factor authentication strategy which uses [TOTP](https://en.wikipedia.org/wiki/Time-based_One-Time_Password) mechanism. <br/>
 * When 2fa is enabled, the strategy will generate a secret, which will be sent to client as QR Image Code (see {@link OnTwoFactorEnabledHookResult.totpSecretQRImageUrl}).
 * Client has to scan this image with his Authenticator App. <br/>
 * During authentication process, when client will receive {@link AuthenticationStepName.TWO_FACTOR_AUTH_CHECK} as {@link AuthenticationStatus.nextStep},
 * he needs to send back 2fa token generated by his app to complete authentication.
 */
class TotpTwoFactorAuthStrategy<Account extends AccountWithTotpSecret> implements TwoFactorAuthStrategy<Account> {
	private readonly authenticator: Authenticator;

	private readonly totpEncryptor: SecretEncryptor;

	private readonly totpSecretLength: number;

	private readonly serviceName: string;

	public constructor(options: TotpTwoFactorAuthStrategyOptions) {
		this.authenticator = new Authenticator({
			...options.totp.authenticator,
			createDigest,
			createRandomBytes,
			keyDecoder,
			keyEncoder
		});
		this.totpEncryptor = new SecretEncryptor(options.totp.encryption);
		this.totpSecretLength = options.totp.secretLength;
		this.serviceName = options.serviceName;
	}

	/**
	 * Generates totp secret and stores it into account.
	 * After that method will generate a QR Image containing secret and return it's URL to client.
	 */
	public async onTwoFactorAuthEnabled(account: Readonly<Account>, update: Partial<Account>): Promise<OnTwoFactorEnabledHookResult> {
		const totpSecret = this.authenticator.generateSecret(this.totpSecretLength);
		update.totpSecret = this.totpEncryptor.encrypt(totpSecret);

		const otpAuth = this.authenticator.keyuri(account.username, this.serviceName, totpSecret);
		return {
			totpSecretQRImageUrl: await qrcode.toDataURL(otpAuth)
		};
	}

	/**
	 * Marks in the {@link AuthenticationSession} that {@link AuthenticationStepName.GENERATE_2FA_TOKEN} has been passed,
	 * and the next step is to validate token from the Authenticator App sent by client. <br/>
	 * An attempt to come back to {@link AuthenticationStepName.GENERATE_2FA_TOKEN} step until previous token validation
	 * will result into an error.
	 */
	public async sendAuthenticationToken(
		account: AccountModel,
		_authenticationContext: AuthenticationContext,
		authenticationSessionRepositoryHolder: AuthenticationSessionRepositoryHolder
	): Promise<void> {
		const authenticationSession = await authenticationSessionRepositoryHolder.get();
		if (authenticationSession['2fa-token'] != null) {
			throw createException(
				ErrorCodes.TWO_FACTOR_AUTH_TOKEN_ISSUED_ALREADY,
				`Two factor authentication token was issued already for authentication session with id '${authenticationSessionRepositoryHolder.sessionId}' belonging to account with id '${account.id}'.`
			);
		}

		authenticationSession['2fa-token'] = 'totp-2fa-marker'; // just to enforce totp as second factor, and not to allow password bypass

		// we do not send any code, because it will be generated by user and sent to us
	}

	/**
	 * Marks in the {@link AuthenticationSession} that {@link AuthenticationStepName.TWO_FACTOR_AUTH_CHECK} step has been passed
	 * (in case valid token is sent by client), and authentication can be finished.
	 */
	public async isAuthenticationTokenValid(
		account: Account,
		authenticationContext: AuthenticationContext,
		authenticationSessionRepositoryHolder: AuthenticationSessionRepositoryHolder
	): Promise<boolean> {
		const authenticationSession = await authenticationSessionRepositoryHolder.get();

		if (authenticationSession['2fa-token'] !== 'totp-2fa-marker') {
			return false;
		}

		if (this.authenticator.check(authenticationContext['2fa-token']!, this.totpEncryptor.decrypt(account.totpSecret))) {
			delete authenticationSession['2fa-token']; // prevent replay attacks
			return true;
		}

		return false;
	}
}

export { TotpTwoFactorAuthStrategy, TotpTwoFactorAuthStrategyOptions, AccountWithTotpSecret, OnTwoFactorEnabledHookResult };
