import qrcode from 'qrcode';
import type { RequireSome } from '@thermopylae/core.declarations/lib';
import type { AuthenticatorOptions } from '@otplib/core';
import { Authenticator } from '@otplib/core';
import { createDigest, createRandomBytes } from '@otplib/plugin-crypto';
import { keyDecoder, keyEncoder } from '@otplib/plugin-thirty-two';
import { createException, ErrorCodes } from '../error';
import { SecretEncryptor } from '../helpers/secret-encryptor';
import type { AuthenticationContext } from '../types/contexts';
import type { AccountModel } from '../types/models';
import type { SecretEncryptionOptions } from '../helpers/secret-encryptor';
import type { TwoFactorAuthStrategy } from './interface';

interface OnTwoFactorEnabledHookResult {
	totpSecretQRImageUrl: string;
}

interface AccountWithTotpSecret extends AccountModel {
	totpSecret: string;
}

interface TotpTwoFactorAuthStrategyOptions {
	readonly totp: {
		secretLength: number;
		encryption: SecretEncryptionOptions | false;
		authenticator: Readonly<
			Omit<
				RequireSome<AuthenticatorOptions<string>, 'algorithm' | 'digits' | 'encoding' | 'step' | 'window'>,
				'createDigest' | 'createHmacKey' | 'digest' | 'epoch' | 'createRandomBytes' | 'keyEncoder' | 'keyDecoder'
			>
		>;
	};
	readonly serviceName: string;
}

class TotpTwoFactorAuthStrategy<Account extends AccountWithTotpSecret> implements TwoFactorAuthStrategy<Account> {
	private readonly authenticator: Authenticator;

	private readonly totpEncryptor: SecretEncryptor;

	private readonly totpSecretLength: number;

	private readonly serviceName: string;

	public constructor(options: TotpTwoFactorAuthStrategyOptions) {
		this.authenticator = new Authenticator({
			...options.totp.authenticator,
			createDigest,
			createRandomBytes,
			keyDecoder,
			keyEncoder
		});
		this.totpEncryptor = new SecretEncryptor(options.totp.encryption);
		this.totpSecretLength = options.totp.secretLength;
		this.serviceName = options.serviceName;
	}

	public async onTwoFactorAuthEnabled(account: Readonly<Account>, update: Partial<Account>): Promise<OnTwoFactorEnabledHookResult> {
		const totpSecret = this.authenticator.generateSecret(this.totpSecretLength);
		update.totpSecret = this.totpEncryptor.encrypt(totpSecret);

		const otpAuth = this.authenticator.keyuri(account.username, this.serviceName, totpSecret);
		return {
			totpSecretQRImageUrl: await qrcode.toDataURL(otpAuth)
		};
	}

	public async sendAuthenticationToken(): Promise<void> {
		// we do not send any code, because it will be generated by user and sent to us
		return undefined;
	}

	public async isAuthenticationTokenValid(account: Account, authenticationContext: AuthenticationContext): Promise<boolean> {
		if (authenticationContext['2fa-token'] == null) {
			throw createException(ErrorCodes.TWO_FACTOR_AUTH_TOKEN_NOT_PROVIDED, 'Totp token was not provided.');
		}
		return this.authenticator.check(authenticationContext['2fa-token'], this.totpEncryptor.decrypt(account.totpSecret));
	}
}

export { TotpTwoFactorAuthStrategy, TotpTwoFactorAuthStrategyOptions, AccountWithTotpSecret, OnTwoFactorEnabledHookResult };
