import { describe, it, beforeEach, afterEach } from 'mocha';
import { expect } from 'chai';
import { string } from '@marin/lib.utils';
import { models } from '@marin/lib.auth-engine';
import { MySqlEnv } from '../setup';
import { AuthRepository } from '../../lib';
import { MySqlClientInstance } from '../../lib/mysql';

describe('account spec', () => {
	const AccountEntity = AuthRepository.generateAccountEntity({
		'table-name': MySqlEnv.tables.account,
		'auto-generated-key': true
	});

	let reconnectAfterTestCase = false;

	async function shutdownMySqlClient(): Promise<void> {
		await MySqlClientInstance.shutdown();
		reconnectAfterTestCase = true;
	}

	afterEach(done => {
		if (reconnectAfterTestCase) {
			MySqlClientInstance.init({ pool: MySqlEnv });
			reconnectAfterTestCase = false;
		}
		MySqlClientInstance.writePool.query(`DELETE FROM ${MySqlEnv.tables.account} WHERE 1=1;`, done);
	});

	describe('create spec', () => {
		it('creates an account (no role, no pubKey)', async () => {
			const account = await AccountEntity.create({
				username: 'username',
				password: 'password',
				salt: 'salt',
				telephone: 'telephone',
				email: 'email',
				mfa: true,
				activated: true,
				locked: true
			});
			// @ts-ignore
			account.role = null;
			// @ts-ignore
			account.pubKey = null;

			expect(account.id).to.be.a('string');
			expect(await AccountEntity.readById(account.id!)).to.be.deep.eq(account);
		});

		it('creates an account (with role, no pubKey)', async () => {
			const account = await AccountEntity.create({
				username: 'username',
				password: 'password',
				salt: 'salt',
				telephone: 'telephone',
				email: 'email',
				mfa: true,
				activated: true,
				locked: true,
				role: 'ADMIN'
			});
			// @ts-ignore
			account.pubKey = null;

			expect(account.id).to.be.a('string');
			expect(await AccountEntity.read(account.username)).to.be.deep.eq(account);
		});

		it('creates an account (no role, with pubKey)', async () => {
			const account = await AccountEntity.create({
				username: 'username',
				password: 'password',
				salt: 'salt',
				telephone: 'telephone',
				email: 'email',
				mfa: true,
				activated: true,
				locked: true,
				pubKey: 'pubKey'
			});
			// @ts-ignore
			account.role = null;

			expect(account.id).to.be.a('string');
			expect(await AccountEntity.readById(account.id!)).to.be.deep.eq(account);
		});

		it('creates an account (with role, with pubKey)', async () => {
			const account = await AccountEntity.create({
				username: 'username',
				password: 'password',
				salt: 'salt',
				telephone: 'telephone',
				email: 'email',
				mfa: true,
				activated: true,
				locked: true,
				role: 'ADMIN',
				pubKey: 'pubKey'
			});

			expect(account.id).to.be.a('string');
			expect(await AccountEntity.readById(account.id!)).to.be.deep.eq(account);
		});

		it('fails to create account if an error occurs', async () => {
			await shutdownMySqlClient();

			let err;
			try {
				await AccountEntity.create({
					username: 'username',
					password: 'password',
					salt: 'salt',
					telephone: 'telephone',
					email: 'email',
					mfa: true,
					activated: true,
					locked: true
				});
			} catch (e) {
				err = e;
			}
			expect(err).to.not.be.eq(undefined);
		});

		it('fails to create account with generated id (auto generated is used)', async () => {
			let err;
			try {
				const AccountEntityNoAutoGenerated = AuthRepository.generateAccountEntity({
					'table-name': MySqlEnv.tables.account
				});
				await AccountEntityNoAutoGenerated.create({
					username: 'username',
					password: 'password',
					salt: 'salt',
					telephone: 'telephone',
					email: 'email',
					mfa: true,
					activated: true,
					locked: true
				});
			} catch (e) {
				err = e;
			}
			expect(err).to.not.be.eq(undefined);
		});
	});

	describe('read by username', () => {
		it('reads an existing account', async () => {
			const account = await AccountEntity.create({
				username: 'username',
				password: 'password',
				salt: 'salt',
				telephone: 'telephone',
				email: 'email',
				mfa: true,
				activated: true,
				locked: true,
				role: 'ADMIN',
				pubKey: 'pubKey'
			});

			expect(account.id).to.be.a('string');
			expect(await AccountEntity.read(account.username)).to.be.deep.eq(account);
		});

		it('returns null when account does not exist', async () => {
			const account = await AccountEntity.read(string.generateStringOfLength(5));
			expect(account).to.be.eq(null);
		});

		it('throws when an error at query level occurs', async () => {
			await shutdownMySqlClient();

			let err;
			try {
				await AccountEntity.read(string.generateStringOfLength(5));
			} catch (e) {
				err = e;
			}
			expect(err).to.not.be.eq(undefined);
		});
	});

	describe('read by id', () => {
		it('reads an existing account', async () => {
			const account = await AccountEntity.create({
				username: 'username',
				password: 'password',
				salt: 'salt',
				telephone: 'telephone',
				email: 'email',
				mfa: true,
				activated: true,
				locked: true,
				role: 'ADMIN',
				pubKey: 'pubKey'
			});

			expect(account.id).to.be.a('string');
			expect(await AccountEntity.readById(account.id!)).to.be.deep.eq(account);
		});

		it('returns null when account does not exist', async () => {
			const account = await AccountEntity.readById(string.generateStringOfLength(5));
			expect(account).to.be.eq(null);
		});

		it('throws when an error at query level occurs', async () => {
			await shutdownMySqlClient();

			let err;
			try {
				await AccountEntity.readById(string.generateStringOfLength(5));
			} catch (e) {
				err = e;
			}
			expect(err).to.not.be.eq(undefined);
		});
	});

	describe('lock account', () => {
		let account: models.AccountModel;

		beforeEach(async () => {
			account = await AccountEntity.create({
				username: 'username',
				password: 'password',
				salt: 'salt',
				telephone: 'telephone',
				email: 'email',
				mfa: true,
				activated: true,
				locked: false,
				role: 'ADMIN',
				pubKey: 'pubKey'
			});
		});

		it('locks account', async () => {
			await AccountEntity.lock(account.id!);
			expect((await AccountEntity.readById(account.id!))!.locked).to.be.eq(true);
		});

		it('fails to lock account if already locked', async () => {
			await AccountEntity.lock(account.id!);

			let err;
			try {
				await AccountEntity.lock(account.id!);
			} catch (e) {
				err = e;
			}
			expect(err).to.not.be.eq(undefined);
		});

		it('fails to lock account when error occurs', async () => {
			await shutdownMySqlClient();

			let err;
			try {
				await AccountEntity.lock(account.id!);
			} catch (e) {
				err = e;
			}
			expect(err).to.not.be.eq(undefined);
		});
	});
});
