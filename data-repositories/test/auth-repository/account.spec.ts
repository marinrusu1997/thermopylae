/* import { string } from '@marin/lib.utils'; */
import { models } from '@marin/lib.auth-engine';
import { MySqlClientInstance } from '@marin/lib.data-access';

import { describe, it, before, afterEach } from 'mocha';
import { expect } from 'chai';
import { MySqlEnv, truncateAllTables } from '../setup';

import { AuthRepository } from '../../lib';
import { AccountEntity } from '../../lib/auth/account';

describe('account spec', () => {
	let reconnectAfterTestCase = false;

	/*	async function shutdownMySqlClient(): Promise<void> {
		await MySqlClientInstance.shutdown();
		reconnectAfterTestCase = true;
	} */

	const DEFAULT_ACCOUNT_ROLE = 'USER';

	before(function (done) {
		this.timeout(30000);

		truncateAllTables((err) => {
			if (err) {
				return done(err);
			}

			return MySqlClientInstance.writePool.query(`INSERT INTO Role (Name) VALUES ('${DEFAULT_ACCOUNT_ROLE}');`, (insertErr, results) => {
				if (insertErr) {
					return done(insertErr);
				}

				if (results.affectedRows !== 1) {
					return done(new Error(`Failed to INSERT default role with name ${DEFAULT_ACCOUNT_ROLE}`));
				}

				return done();
			});
		});
	});

	afterEach((done) => {
		if (reconnectAfterTestCase) {
			MySqlClientInstance.init({ pool: MySqlEnv });
			reconnectAfterTestCase = false;
		}
		MySqlClientInstance.writePool.query('DELETE FROM Account;', done);
	});

	describe('create spec', () => {
		it('creates an account', async () => {
			const account: models.AccountModel = {
				username: 'username',
				password: 'password',
				salt: 'salt',
				telephone: 'telephone',
				email: 'email',
				usingMfa: true,
				enabled: true,
				role: DEFAULT_ACCOUNT_ROLE
			};
			account.id = await AuthRepository.accountEntity.create(account);

			expect(account.id.length).to.be.eq(AccountEntity.ACCOUNT_ID_LENGTH);
		});

		// FIXME insert multiple users, different scenarios

		/* it('creates an account (no role, no pubKey)', async () => {
			const account = await AccountEntity.create({
				username: 'username',
				password: 'password',
				salt: 'salt',
				telephone: 'telephone',
				email: 'email',
				mfa: true,
				activated: true,
				locked: true
			});
			// @ts-ignore
			account.role = null;
			// @ts-ignore
			account.pubKey = null;

			expect(account.id).to.be.a('string');
			expect(await AccountEntity.readById(account.id!)).to.be.deep.eq(account);
		});

		it('creates an account (with role, no pubKey)', async () => {
			const account = await AccountEntity.create({
				username: 'username',
				password: 'password',
				salt: 'salt',
				telephone: 'telephone',
				email: 'email',
				mfa: true,
				activated: true,
				locked: true,
				role: 'ADMIN'
			});
			// @ts-ignore
			account.pubKey = null;

			expect(account.id).to.be.a('string');
			expect(await AccountEntity.read(account.username)).to.be.deep.eq(account);
		});

		it('creates an account (no role, with pubKey)', async () => {
			const account = await AccountEntity.create({
				username: 'username',
				password: 'password',
				salt: 'salt',
				telephone: 'telephone',
				email: 'email',
				mfa: true,
				activated: true,
				locked: true,
				pubKey: 'pubKey'
			});
			// @ts-ignore
			account.role = null;

			expect(account.id).to.be.a('string');
			expect(await AccountEntity.readById(account.id!)).to.be.deep.eq(account);
		});

		it('creates an account (with role, with pubKey)', async () => {
			const account = await AccountEntity.create({
				username: 'username',
				password: 'password',
				salt: 'salt',
				telephone: 'telephone',
				email: 'email',
				mfa: true,
				activated: true,
				locked: true,
				role: 'ADMIN',
				pubKey: 'pubKey'
			});

			expect(account.id).to.be.a('string');
			expect(await AccountEntity.readById(account.id!)).to.be.deep.eq(account);
		});

		it('fails to create account if an error occurs', async () => {
			await shutdownMySqlClient();

			let err;
			try {
				await AccountEntity.create({
					username: 'username',
					password: 'password',
					salt: 'salt',
					telephone: 'telephone',
					email: 'email',
					mfa: true,
					activated: true,
					locked: true
				});
			} catch (e) {
				err = e;
			}
			expect(err).to.not.be.eq(undefined);
		});

		it('fails to create account with generated id (auto generated is used)', async () => {
			let err;
			try {
				const AccountEntityNoAutoGenerated = AuthRepository.generateAccountEntity({
					'table-name': MySqlEnv.tables.account
				});
				await AccountEntityNoAutoGenerated.create({
					username: 'username',
					password: 'password',
					salt: 'salt',
					telephone: 'telephone',
					email: 'email',
					mfa: true,
					activated: true,
					locked: true
				});
			} catch (e) {
				err = e;
			}
			expect(err).to.not.be.eq(undefined);
		}); */
	});

	/*	describe('read by username', () => {
		it('reads an existing account', async () => {
			const account = await AccountEntity.create({
				username: 'username',
				password: 'password',
				salt: 'salt',
				telephone: 'telephone',
				email: 'email',
				mfa: true,
				activated: true,
				locked: true,
				role: 'ADMIN',
				pubKey: 'pubKey'
			});

			expect(account.id).to.be.a('string');
			expect(await AccountEntity.read(account.username)).to.be.deep.eq(account);
		});

		it('returns null when account does not exist', async () => {
			const account = await AccountEntity.read(string.generateStringOfLength(5));
			expect(account).to.be.eq(null);
		});

		it('throws when an error at query level occurs', async () => {
			await shutdownMySqlClient();

			let err;
			try {
				await AccountEntity.read(string.generateStringOfLength(5));
			} catch (e) {
				err = e;
			}
			expect(err).to.not.be.eq(undefined);
		});
	});

	describe('read by id', () => {
		it('reads an existing account', async () => {
			const account = await AccountEntity.create({
				username: 'username',
				password: 'password',
				salt: 'salt',
				telephone: 'telephone',
				email: 'email',
				mfa: true,
				activated: true,
				locked: true,
				role: 'ADMIN',
				pubKey: 'pubKey'
			});

			expect(account.id).to.be.a('string');
			expect(await AccountEntity.readById(account.id!)).to.be.deep.eq(account);
		});

		it('returns null when account does not exist', async () => {
			const account = await AccountEntity.readById(string.generateStringOfLength(5));
			expect(account).to.be.eq(null);
		});

		it('throws when an error at query level occurs', async () => {
			await shutdownMySqlClient();

			let err;
			try {
				await AccountEntity.readById(string.generateStringOfLength(5));
			} catch (e) {
				err = e;
			}
			expect(err).to.not.be.eq(undefined);
		});
	});

	describe('lock account', () => {
		let account: models.AccountModel;

		beforeEach(async () => {
			account = await AccountEntity.create({
				username: 'username',
				password: 'password',
				salt: 'salt',
				telephone: 'telephone',
				email: 'email',
				mfa: true,
				activated: true,
				locked: false,
				role: 'ADMIN',
				pubKey: 'pubKey'
			});
		});

		it('locks account', async () => {
			await AccountEntity.lock(account.id!);
			expect((await AccountEntity.readById(account.id!))!.locked).to.be.eq(true);
		});

		it('fails to lock account if already locked', async () => {
			await AccountEntity.lock(account.id!);

			let err;
			try {
				await AccountEntity.lock(account.id!);
			} catch (e) {
				err = e;
			}
			expect(err).to.not.be.eq(undefined);
		});

		it('fails to lock account when error occurs', async () => {
			await shutdownMySqlClient();

			let err;
			try {
				await AccountEntity.lock(account.id!);
			} catch (e) {
				err = e;
			}
			expect(err).to.not.be.eq(undefined);
		});
	}); */
});
